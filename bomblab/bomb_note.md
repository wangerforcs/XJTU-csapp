### phase1
输入字符串，判断是否与给定字符串相等
经查看应该输入
I am just a renegade hockey mom.

### phase2 
输入6个数字
利用read_six_number读取
%rdi存字符串指针，%rsi存格式化字符串的指针"%d %d %d %d %d %d"，rdx，rcx，r8，r9，以及0x10个栈字节存放栈中六个数对应的指针
并传入函数进行输入，返回后依次比较栈中数据判断是否为斐波那契数列
由于要求1、2项为0、1，那么可以确定输入为
0 1 1 2 3 5
分配的栈：0 4 8 c 10 14 18(canary) 1c 20 24 28

### phase3
输入2个数字
%rdi存字符串指针，%rsi存"%d %d"指针，%rdx，%rcx存栈指针
0 4 8(canary) c 10 14 18
0<=x<=7，也许是switch(?)
根据输入的数字，计算跳转指令的地址，判断是否与对应指令的数字相等
根据实际尝试，我选择了0 ，0x340

### phase4
输入2个数字 0<=x<=14，fun(x,0,14)返回值
func4 参数abc
d=(((c-b)>>31+(c-b))>>1)+b与a比大小
    逻辑          算术
即d=(b+c)/2与a比大小
- x大返回fun(a,d+1,c)+d
- x小返回fun(a,b,d-1)+d
- =返回d  

原来是二分(喜)
调用func4 %rdi存x，%esi存0，%edx存14
7+11+9+8=35
分别对应于0-14 8-14 8-10 8-8
即输入为8 35
分配的栈：0 4 8(canary) c 10 14 18

### phase5
输入长度为6的字符串
0x194e(%rip)存的2，放在rsi中
要求给定方法求得和为35(0x23)的串
以字符的ascii低4位为索引，获取数据区的array数据，求和
array为
2  10 6  1 
12 16 9  3 
4  7  15 5 
11 8  15 14
可取1+2+6+6+10+10，如sprrqq

### phase6
输入6个数字
0 4 8 c 10 14 18 1c 20 24 28 2c 30 34 38 3c 40 44 48 4c 50 54 58(canary) 5c 60
六个数字均小于等于6，且不重复，好难，花费了很长时间
1871为检查完输入数字属性后进入的指令
0x555555559210 <node1>: 0x0000011a      0x00000001      0x55559220      0x00005555
0x555555559220 <node2>: 0x00000307      0x00000002      0x55559230      0x00005555
0x555555559230 <node3>: 0x000000b8      0x00000003      0x55559240      0x00005555
0x555555559240 <node4>: 0x0000038a      0x00000004      0x55559250      0x00005555
0x555555559250 <node5>: 0x00000153      0x00000005      0x55559110      0x00005555
0x555555559110 <node6>: 0x0000005e      0x00000006      0x00000000      0x00000000
根据输入的数字x，依次选择将编号(node 第二个字节)为x的结点的指针加入栈中
然后根据在栈中的数据排序，更新next指针，形成新链表
最后判断是否为递减顺序
因此输入的数字应为6 3 1 5 2 4

### secret_phase
输入串以十进制转为long int
然后调用func7(a,b) 
- a为0 返回0xffffffff(-1?)
- 否则比较*a,b
    - *a大则调用fun(a.left,b),返回2fun(a.left,b)
    - *a小则调用fun(a.right,b),返回2fun(a.right,b)+1   
- 相等则返回0(这不二叉搜索树吗)

查看得树只有一个节点，值为0x24
(gdb) x /4x $rdi
0x555555559130 <n1>:    0x24    0x00    0x00    0x00
实际调用a=%rip+0x379d(即上方节点地址),b=strtol返回值，要求调用函数返回值为0
那么输入36第一次与0x24比较相等即可

### phase_defuse
使用%rip获取num of strings，得分
"phase_%d defused! Congrates!\n"
"The score you've got now is: \n(%d/100)\n"
输入字符串个数等于6时，查看得再次尝试输入格式为"%d %d %s"
并且尝试输出发现函数复用了phase4的输入串，以及获得的要对比的字符串为"DrEvil"(这步找了好长时间，还在下边注释里犯错误了，前几个phase竟然没错)
因此对第四个输入进行更改为8 35 DrEvil
注释：使用x /x ......获取0x****(%rip)里的内容要在该命令执行后。